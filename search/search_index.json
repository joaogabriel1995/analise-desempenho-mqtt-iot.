{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Calculo de performance com Locust e MQTT. Antes de apresentar os c\u00f3digos que ser\u00e3o utilizados para o nosso teste irei abordar alguns assuntos que acredito ser importante para um bom entendimento do que ser\u00e1 repassado a frente. Todos os c\u00f3digos que ser\u00e3o explicados nessa p\u00e1gina est\u00e3o disponiveis no meu Github . MQTT O protocolo MQTT (Message Queuing Telemetry Transport) \u00e9 um protocolo de comunica\u00e7\u00e3o entre m\u00e1quinas (Machine to Machine \u2013 M2M) que vem se consolidando como o principal protocolo para implementa\u00e7\u00f5es de IoT (SOUZA, 2019); (CORREA et. al, 2016) Esse protocolo foi criado e desenvolvido pela IBM na d\u00e9cada de 90 e tinha como objetivo original monitorar gasodutos e plataformas de petr\u00f3leos. Como essas plataformas de petr\u00f3leo e gasodutos geralmente se localizadas em lugares remotos o protocolo foi desenvolvido com a finalidade de operar em ambientes de largura de banda muito baixa, permitindo a troca de informa\u00e7\u00f5es onde alguns outros protocolos n\u00e3o conseguiam realizar tais trocas de dados. A arquitetura do MQTT \u00e9 do tipo publica\u00e7\u00e3o e assinatura (publish-subscribers). Nessa arquitetura, o dispositivo \u00e9 respons\u00e1vel por enviar (publish) as informa\u00e7\u00f5es ao servidor, que opera como um intermedi\u00e1rio (broker). Tendo conhecimento dos clientes que est\u00e3o interessados nas informa\u00e7\u00f5es enviadas (subscribers), o broker retransmite as informa\u00e7\u00f5es recebidas. A Fig. 1 exemplifica diversos tipos de dispositivos conectados recebendo e enviando informa\u00e7\u00f5es. Pode ser analisado que um mesmo dispositivo pode realizar o papel de publish e subscribers. arquitetura-iot_1 Figura 1 \u2013 Protocolos TCP/IP e OSI Fonte: ALTUS, 2021. O principal objetivo desse teste ser\u00e1 calcular o tempo de ida e volta (RTT) de uma mensagem. O que \u00e9 Round Trip Time (RTT)? O RTT \u00e9 a dura\u00e7\u00e3o em milissegundos (ms) que uma solicita\u00e7\u00e3o de rede leva para ir de um ponto de partida a um destino e de volta ao ponto de partida. Figura 2 - Round Trip Time (RTT) Locust Figura 3 - Locust O Locust \u00e9 uma ferramenta de teste de performance f\u00e1cil de usar, program\u00e1vel e escal\u00e1vel. O comportamento do usu\u00e1rio \u00e9 definindo por c\u00f3digo python, ent\u00e3o \u00e9 muito customiz\u00e1vel. Em nosso teste iremos definir o comportamento de um dispositivo IoT publicando mensagens em um determinado t\u00f3pico. O Locust s\u00f3 vem com suporte embutido para HTTP/HTTPS, mas pode ser estendido para testar quase qualquer protocolo. Para para mais informa\u00e7\u00f5es sobre o Locust, clique aqui . Wireshark Figura 4 - Wireshark O Wireshark \u00e9 um programa para an\u00e1lise de protocolo de rede em c\u00f3digo aberto, com esse programa \u00e9 possivel verificar o funcionamento de uma rede. De maneira geral, os analisadores de pacotes s\u00e3o compostos por duas partes: O m\u00f3dulo de captura de pacotes (Packet Capture Library) O analisador de protocolos (Protocol Analyzer). O primeiro \u00e9 responsavel por capturar todos os pacotes que trafegam pela placa de rede que foi especificada, j\u00e1 o segundo \u00e9 responsavel por interpretar os cabe\u00e7alhos e conte\u00fados dos pacotes. Esse programa ser\u00e1 fundamental para analisarmos os resultados do nosso teste. Nos permitindo capturar o tempo da saida do nosso pacote e a capturar o tempo de chegada do nosso pacote de confirma\u00e7\u00e3o de recebimento do broker. Para para mais informa\u00e7\u00f5es sobre o Wireshark, clique aqui .","title":"Introdu\u00e7\u00e3o"},{"location":"#calculo-de-performance-com-locust-e-mqtt","text":"Antes de apresentar os c\u00f3digos que ser\u00e3o utilizados para o nosso teste irei abordar alguns assuntos que acredito ser importante para um bom entendimento do que ser\u00e1 repassado a frente. Todos os c\u00f3digos que ser\u00e3o explicados nessa p\u00e1gina est\u00e3o disponiveis no meu Github .","title":"Calculo de performance com Locust e MQTT."},{"location":"#mqtt","text":"O protocolo MQTT (Message Queuing Telemetry Transport) \u00e9 um protocolo de comunica\u00e7\u00e3o entre m\u00e1quinas (Machine to Machine \u2013 M2M) que vem se consolidando como o principal protocolo para implementa\u00e7\u00f5es de IoT (SOUZA, 2019); (CORREA et. al, 2016) Esse protocolo foi criado e desenvolvido pela IBM na d\u00e9cada de 90 e tinha como objetivo original monitorar gasodutos e plataformas de petr\u00f3leos. Como essas plataformas de petr\u00f3leo e gasodutos geralmente se localizadas em lugares remotos o protocolo foi desenvolvido com a finalidade de operar em ambientes de largura de banda muito baixa, permitindo a troca de informa\u00e7\u00f5es onde alguns outros protocolos n\u00e3o conseguiam realizar tais trocas de dados. A arquitetura do MQTT \u00e9 do tipo publica\u00e7\u00e3o e assinatura (publish-subscribers). Nessa arquitetura, o dispositivo \u00e9 respons\u00e1vel por enviar (publish) as informa\u00e7\u00f5es ao servidor, que opera como um intermedi\u00e1rio (broker). Tendo conhecimento dos clientes que est\u00e3o interessados nas informa\u00e7\u00f5es enviadas (subscribers), o broker retransmite as informa\u00e7\u00f5es recebidas. A Fig. 1 exemplifica diversos tipos de dispositivos conectados recebendo e enviando informa\u00e7\u00f5es. Pode ser analisado que um mesmo dispositivo pode realizar o papel de publish e subscribers. arquitetura-iot_1 Figura 1 \u2013 Protocolos TCP/IP e OSI Fonte: ALTUS, 2021. O principal objetivo desse teste ser\u00e1 calcular o tempo de ida e volta (RTT) de uma mensagem.","title":"MQTT"},{"location":"#o-que-e-round-trip-time-rtt","text":"O RTT \u00e9 a dura\u00e7\u00e3o em milissegundos (ms) que uma solicita\u00e7\u00e3o de rede leva para ir de um ponto de partida a um destino e de volta ao ponto de partida. Figura 2 - Round Trip Time (RTT)","title":"O que \u00e9 Round Trip Time (RTT)?"},{"location":"#locust","text":"Figura 3 - Locust O Locust \u00e9 uma ferramenta de teste de performance f\u00e1cil de usar, program\u00e1vel e escal\u00e1vel. O comportamento do usu\u00e1rio \u00e9 definindo por c\u00f3digo python, ent\u00e3o \u00e9 muito customiz\u00e1vel. Em nosso teste iremos definir o comportamento de um dispositivo IoT publicando mensagens em um determinado t\u00f3pico. O Locust s\u00f3 vem com suporte embutido para HTTP/HTTPS, mas pode ser estendido para testar quase qualquer protocolo. Para para mais informa\u00e7\u00f5es sobre o Locust, clique aqui .","title":"Locust"},{"location":"#wireshark","text":"Figura 4 - Wireshark O Wireshark \u00e9 um programa para an\u00e1lise de protocolo de rede em c\u00f3digo aberto, com esse programa \u00e9 possivel verificar o funcionamento de uma rede. De maneira geral, os analisadores de pacotes s\u00e3o compostos por duas partes: O m\u00f3dulo de captura de pacotes (Packet Capture Library) O analisador de protocolos (Protocol Analyzer). O primeiro \u00e9 responsavel por capturar todos os pacotes que trafegam pela placa de rede que foi especificada, j\u00e1 o segundo \u00e9 responsavel por interpretar os cabe\u00e7alhos e conte\u00fados dos pacotes. Esse programa ser\u00e1 fundamental para analisarmos os resultados do nosso teste. Nos permitindo capturar o tempo da saida do nosso pacote e a capturar o tempo de chegada do nosso pacote de confirma\u00e7\u00e3o de recebimento do broker. Para para mais informa\u00e7\u00f5es sobre o Wireshark, clique aqui .","title":"Wireshark"},{"location":"code/","text":"Locust Agora, vamos analisar o arquivo locustfile.py e vamos destrinchar o c\u00f3digo. Como podemos analisar o arquivo locust \u00e9 um m\u00f3dulo Python normal, ele pode importar c\u00f3digo de outros arquivos ou pacotes. Nesse primeiro momento irei explicar os c\u00f3digos e resultados para os testes sem a utiliza\u00e7\u00e3o do protocolo de seguran\u00e7a Transport Layer Security (TLS) Segue abaixo um fluxograma reduzido de como \u00e9 realizado a simula\u00e7\u00e3o dos nossos dispositivos. Figura 5 - Fluxograma da simula\u00e7\u00e3o Esse fluxo ser\u00e1 realizado por nosso script que ser\u00e1 explicado logo abaixo. Import import time from locust import User , TaskSet , events , task import paho.mqtt.client as mqtt Primeiro iremos definir uma classe para os usu\u00e1rios que iremos simular. Essa classe herda da classe User do Locust. Iremos inicializar essa classe com o nosso m\u00e9todo construtor __init__ e iremos utilizar super() , fun\u00e7\u00e3o que nos permite sobrescrever m\u00e9todos e alterar comportamentos. Classe User 1 2 3 4 5 6 7 8 9 10 11 12 13 class MQTTLocust ( User ): tasks = { PublishTask } _locust_environment = None wait_time = constant ( WAIT_TIME ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) increment () self . client_name = \"Device - \" + str ( COUNTClient ) self . client = mqtt . Client ( self . client_name ) self . client . on_connect = self . on_connect self . client . on_publish = self . on_publish self . client . pubmessage = {} Aqui estamos importando o m\u00e9todo init da classe pai, e o sobrescrevendo para adicionar nosso self.client que \u00e9 uma inst\u00e2ncia de paho.mqtt.client.Client , esse cliente MQTT pode ser usado para publicar e receber mensagens. Quando o teste \u00e9 iniciado, o locust criar\u00e1 uma inst\u00e2ncia para cada cliente que for simulado. Cada um desses clients ser\u00e1 executado em um micro-thread. O comportamento deste usu\u00e1rio \u00e9 definido por tarefas que ser\u00e3o definidas mais a frente. Na linha 3 estamos mostrando para nossa classe MQTTLocust as tarefas que nossos clientes executar\u00e3o. Nas linhas 11 e 12 foi associada as fun\u00e7\u00f5es de callback, essas fun\u00e7\u00f5es s\u00e3o executadas em resposta a algum evento. Irei detalhar cada uma delas abaixo. Callbacks MQTT A fun\u00e7\u00e3o on_connect \u00e9 chamada quando o Broker responde \u00e0 nossa solicita\u00e7\u00e3o de conex\u00e3o. 1 2 def on_connect ( client , userdata , flags , rc , props = None ): print ( \"Connect \" , client ) A fun\u00e7\u00e3o on_publish \u00e9 executada quando uma mensagem concluiu a transmiss\u00e3o para o broker. Para mensagens com n\u00edveis de QoS 1 e 2, isso significa que as mensagens foram entregues ao broker. Para QoS 0, isso significa simplesmente que a mensagem deixou o cliente. Na linha 3 da nossa fun\u00e7\u00e3o on_publish iremos capturar o tempo em que a mensagem de confirma\u00e7\u00e3o chegou. Na linha 8 foi vinculado a um evento que \u00e9 relacionado ao Locust, esse evento \u00e9 acionado quando uma solicita\u00e7\u00e3o \u00e9 concluida, bem-sucedidade ou malsucedidade. Isso \u00e9 um modo de informarmos ao locust o fim de uma solicita\u00e7\u00e3o, o tempo em que essa solicita\u00e7\u00e3o foi finalizada e possibilitando que esses valores sejam apresentadas em uma interface que o Locust possui para visualizar os resultados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def on_publish ( self , client , userdata , mid ): self . end_time = get_time () mid = \" {} - {} \" . format ( mid , self . client_name ) message = client . pubmessage . pop ( mid , None ) total_time = time_delta ( message . start_time , self . end_time ) events . request . fire ( request_type = REQUEST_TYPE , name = \" {} \" . format ( str ( self . client_name )), response_time = total_time , response_length = len ( message . payload ), response = None , context = {}, exception = None , start_time = message . start_time , url = None , ) TaskSet Classe que define um conjunto de tarefas que um usu\u00e1rio executar\u00e1. Aqui iremos definir duas tarefas , uma quando o teste come\u00e7ar os clientes ir\u00e3o conectar ao broker e logo em seguida ir\u00e3o desconecta. Ja a segunda tarefa que foi definida \u00e9 mais complexa, nessa tarefa o cliente conectar\u00e1 ao Broker, capturar o tempo logo ap\u00f3s a conex\u00e3o e envia uma mensagem em um t\u00f3pico espec\u00edfico e ap\u00f3s desconecta do broker. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class PublishTask ( TaskSet ): def on_start ( self ): self . client . connect ( host = broker_address , port = PORT_HOST , keepalive = 60 ) @task ( 1 ) def task_pub ( self ): self . client . loop_start () self . start_time = get_time () topic = str ( self . client . _client_id ) payload = formatpayload ( SIZE_PAYLOAD ) MQTTMessageInfo = self . client . publish ( topic , payload , qos = 1 , retain = False ) pub_mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) MQTTMessageInfo . mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) self . client . user_data_set ( pub_mid ) self . client . pubmessage [ pub_mid ] = Message ( REQUEST_TYPE , 1 , topic , payload , self . start_time , PUBLISH_TIMEOUT , str ( self . client . _client_id ), ) MQTTMessageInfo . wait_for_publish () self . client . loop_stop () def on_stop ( self ): global COUNTClient COUNTClient = 0 return super () . on_stop () Podemos perceber que j\u00e1 definimos os dois tempos que ser\u00e3o utilizados pelo Locust, um tempo que \u00e9 capturado assim que a mensagem vai ser enviada e um segundo tempo que foi capturado logo ap\u00f3s a confirma\u00e7\u00e3o de recebimento. Esse segundo tempo \u00e9 capturado quando a fun\u00e7\u00e3o de callback on_publish \u00e9 chamada. Class Message Temos uma classe que Message, essa classe fica responsavel por criar um objeto que temos as informa\u00e7\u00f5es da nossa mensagem. Isso facilita manipula\u00e7\u00e3o da mensagem se for necess\u00e1rio. Essa classe ficou alocada no arquivo message.py class Message ( object ): def __init__ ( self , type , qos , topic , payload , start_time , timeout , name ): self . type = ( type ,) self . qos = ( qos ,) self . topic = topic self . payload = payload self . start_time = start_time self . timeout = timeout self . name = name Utils Criamos tr\u00eas fun\u00e7\u00f5es em um arquivo denominado utils : Uma para calcular a diferen\u00e7a de tempo de chegada da nossa mensagem menos o tempo de chegada da nossa confirma\u00e7\u00e3o de entrega. def time_delta ( t1 , t2 ): return int (( t2 - t1 )) ``` - Uma fun\u00e7\u00e3o responsavel por capturar o tempo em um determinado parte no c\u00f3digo . ``` py def get_time (): time_info = time . time () * 1000 return time_info ``` - Uma fun\u00e7\u00e3o respons\u00e1vel por formatal o tamanho do nosso payload . ``` py def formatpayload ( SIZE_PAYLOAD ): payload = \"0\" * SIZE_PAYLOAD return payload Por \u00faltimos irei definir algumas variav\u00e9is que iremos utilizar em nosso c\u00f3digo. broker_address : str = \"192.168.15.3\" COUNTClient : int = 0 REQUEST_TYPE : str = \"MQTT\" PUBLISH_TIMEOUT : int = 10000 SIZE_PAYLOAD : int = 6 PORT_HOST : int = 1883 WAIT_TIME : int = 1 Segue abaixo o c\u00f3digo completo. locustfile.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import time from locust import User , TaskSet , events , task , constant import paho.mqtt.client as mqtt from utils import get_time , formatpayload , time_delta from message import Message broker_address : str = \"192.168.15.3\" COUNTClient : int = 0 REQUEST_TYPE : str = \"MQTT\" PUBLISH_TIMEOUT : int = 10000 SIZE_PAYLOAD : int = 6 PORT_HOST : int = 1883 WAIT_TIME : int = 1 def increment (): global COUNTClient COUNTClient = COUNTClient + 1 class PublishTask ( TaskSet ): def on_start ( self ): self . client . connect ( host = broker_address , port = PORT_HOST , keepalive = 60 ) @task ( 1 ) def task_pub ( self ): self . client . loop_start () self . start_time = get_time () topic = str ( self . client . _client_id ) payload = formatpayload ( SIZE_PAYLOAD ) MQTTMessageInfo = self . client . publish ( topic , payload , qos = 1 , retain = False ) pub_mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) MQTTMessageInfo . mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) self . client . user_data_set ( pub_mid ) self . client . pubmessage [ pub_mid ] = Message ( REQUEST_TYPE , 1 , topic , payload , self . start_time , PUBLISH_TIMEOUT , str ( self . client . _client_id ), ) MQTTMessageInfo . wait_for_publish () self . client . loop_stop () def on_stop ( self ): global COUNTClient COUNTClient = 0 return super () . on_stop () class MQTTLocust ( User ): tasks = { PublishTask } _locust_environment = None wait_time = constant ( WAIT_TIME ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) increment () self . client_name = \"Device - \" + str ( COUNTClient ) self . client = mqtt . Client ( self . client_name ) self . client . on_connect = self . on_connect self . client . on_publish = self . on_publish self . client . pubmessage = {} def on_connect ( client , userdata , flags , rc , props = None ): print ( \"Connect\" ) def on_publish ( self , client , userdata , mid ): self . end_time = get_time () mid = \" {} - {} \" . format ( mid , self . client_name ) message = client . pubmessage . pop ( mid , None ) total_time = time_delta ( message . start_time , self . end_time ) events . request . fire ( request_type = REQUEST_TYPE , name = \" {} \" . format ( str ( self . client_name )), response_time = total_time , response_length = len ( message . payload ), response = None , context = {}, exception = None , start_time = message . start_time , url = None , ) utils.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time def time_delta ( t1 , t2 ): return int (( t2 - t1 )) def get_time (): time_info = time . time () * 1000 return time_info def formatpayload ( SIZE_PAYLOAD ): payload = \"0\" * SIZE_PAYLOAD return payload message.py 1 2 3 4 5 6 7 8 9 class Message ( object ): def __init__ ( self , type , qos , topic , payload , start_time , timeout , name ): self . type = ( type ,) self . qos = ( qos ,) self . topic = topic self . payload = payload self . start_time = start_time self . timeout = timeout self . name = name Agora que j\u00e1 foi explicado as partes mais importantes do c\u00f3digo iremos rodar esse comando no terminal. Shell locust -f locustfile.py","title":"C\u00f3digo para Simula\u00e7\u00e3o"},{"location":"code/#locust","text":"Agora, vamos analisar o arquivo locustfile.py e vamos destrinchar o c\u00f3digo. Como podemos analisar o arquivo locust \u00e9 um m\u00f3dulo Python normal, ele pode importar c\u00f3digo de outros arquivos ou pacotes. Nesse primeiro momento irei explicar os c\u00f3digos e resultados para os testes sem a utiliza\u00e7\u00e3o do protocolo de seguran\u00e7a Transport Layer Security (TLS) Segue abaixo um fluxograma reduzido de como \u00e9 realizado a simula\u00e7\u00e3o dos nossos dispositivos. Figura 5 - Fluxograma da simula\u00e7\u00e3o Esse fluxo ser\u00e1 realizado por nosso script que ser\u00e1 explicado logo abaixo.","title":"Locust"},{"location":"code/#import","text":"import time from locust import User , TaskSet , events , task import paho.mqtt.client as mqtt Primeiro iremos definir uma classe para os usu\u00e1rios que iremos simular. Essa classe herda da classe User do Locust. Iremos inicializar essa classe com o nosso m\u00e9todo construtor __init__ e iremos utilizar super() , fun\u00e7\u00e3o que nos permite sobrescrever m\u00e9todos e alterar comportamentos.","title":"Import"},{"location":"code/#classe-user","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class MQTTLocust ( User ): tasks = { PublishTask } _locust_environment = None wait_time = constant ( WAIT_TIME ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) increment () self . client_name = \"Device - \" + str ( COUNTClient ) self . client = mqtt . Client ( self . client_name ) self . client . on_connect = self . on_connect self . client . on_publish = self . on_publish self . client . pubmessage = {} Aqui estamos importando o m\u00e9todo init da classe pai, e o sobrescrevendo para adicionar nosso self.client que \u00e9 uma inst\u00e2ncia de paho.mqtt.client.Client , esse cliente MQTT pode ser usado para publicar e receber mensagens. Quando o teste \u00e9 iniciado, o locust criar\u00e1 uma inst\u00e2ncia para cada cliente que for simulado. Cada um desses clients ser\u00e1 executado em um micro-thread. O comportamento deste usu\u00e1rio \u00e9 definido por tarefas que ser\u00e3o definidas mais a frente. Na linha 3 estamos mostrando para nossa classe MQTTLocust as tarefas que nossos clientes executar\u00e3o. Nas linhas 11 e 12 foi associada as fun\u00e7\u00f5es de callback, essas fun\u00e7\u00f5es s\u00e3o executadas em resposta a algum evento. Irei detalhar cada uma delas abaixo.","title":"Classe User"},{"location":"code/#callbacks-mqtt","text":"A fun\u00e7\u00e3o on_connect \u00e9 chamada quando o Broker responde \u00e0 nossa solicita\u00e7\u00e3o de conex\u00e3o. 1 2 def on_connect ( client , userdata , flags , rc , props = None ): print ( \"Connect \" , client ) A fun\u00e7\u00e3o on_publish \u00e9 executada quando uma mensagem concluiu a transmiss\u00e3o para o broker. Para mensagens com n\u00edveis de QoS 1 e 2, isso significa que as mensagens foram entregues ao broker. Para QoS 0, isso significa simplesmente que a mensagem deixou o cliente. Na linha 3 da nossa fun\u00e7\u00e3o on_publish iremos capturar o tempo em que a mensagem de confirma\u00e7\u00e3o chegou. Na linha 8 foi vinculado a um evento que \u00e9 relacionado ao Locust, esse evento \u00e9 acionado quando uma solicita\u00e7\u00e3o \u00e9 concluida, bem-sucedidade ou malsucedidade. Isso \u00e9 um modo de informarmos ao locust o fim de uma solicita\u00e7\u00e3o, o tempo em que essa solicita\u00e7\u00e3o foi finalizada e possibilitando que esses valores sejam apresentadas em uma interface que o Locust possui para visualizar os resultados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def on_publish ( self , client , userdata , mid ): self . end_time = get_time () mid = \" {} - {} \" . format ( mid , self . client_name ) message = client . pubmessage . pop ( mid , None ) total_time = time_delta ( message . start_time , self . end_time ) events . request . fire ( request_type = REQUEST_TYPE , name = \" {} \" . format ( str ( self . client_name )), response_time = total_time , response_length = len ( message . payload ), response = None , context = {}, exception = None , start_time = message . start_time , url = None , )","title":"Callbacks MQTT"},{"location":"code/#taskset","text":"Classe que define um conjunto de tarefas que um usu\u00e1rio executar\u00e1. Aqui iremos definir duas tarefas , uma quando o teste come\u00e7ar os clientes ir\u00e3o conectar ao broker e logo em seguida ir\u00e3o desconecta. Ja a segunda tarefa que foi definida \u00e9 mais complexa, nessa tarefa o cliente conectar\u00e1 ao Broker, capturar o tempo logo ap\u00f3s a conex\u00e3o e envia uma mensagem em um t\u00f3pico espec\u00edfico e ap\u00f3s desconecta do broker. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class PublishTask ( TaskSet ): def on_start ( self ): self . client . connect ( host = broker_address , port = PORT_HOST , keepalive = 60 ) @task ( 1 ) def task_pub ( self ): self . client . loop_start () self . start_time = get_time () topic = str ( self . client . _client_id ) payload = formatpayload ( SIZE_PAYLOAD ) MQTTMessageInfo = self . client . publish ( topic , payload , qos = 1 , retain = False ) pub_mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) MQTTMessageInfo . mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) self . client . user_data_set ( pub_mid ) self . client . pubmessage [ pub_mid ] = Message ( REQUEST_TYPE , 1 , topic , payload , self . start_time , PUBLISH_TIMEOUT , str ( self . client . _client_id ), ) MQTTMessageInfo . wait_for_publish () self . client . loop_stop () def on_stop ( self ): global COUNTClient COUNTClient = 0 return super () . on_stop () Podemos perceber que j\u00e1 definimos os dois tempos que ser\u00e3o utilizados pelo Locust, um tempo que \u00e9 capturado assim que a mensagem vai ser enviada e um segundo tempo que foi capturado logo ap\u00f3s a confirma\u00e7\u00e3o de recebimento. Esse segundo tempo \u00e9 capturado quando a fun\u00e7\u00e3o de callback on_publish \u00e9 chamada.","title":"TaskSet"},{"location":"code/#class-message","text":"Temos uma classe que Message, essa classe fica responsavel por criar um objeto que temos as informa\u00e7\u00f5es da nossa mensagem. Isso facilita manipula\u00e7\u00e3o da mensagem se for necess\u00e1rio. Essa classe ficou alocada no arquivo message.py class Message ( object ): def __init__ ( self , type , qos , topic , payload , start_time , timeout , name ): self . type = ( type ,) self . qos = ( qos ,) self . topic = topic self . payload = payload self . start_time = start_time self . timeout = timeout self . name = name","title":"Class Message"},{"location":"code/#utils","text":"Criamos tr\u00eas fun\u00e7\u00f5es em um arquivo denominado utils : Uma para calcular a diferen\u00e7a de tempo de chegada da nossa mensagem menos o tempo de chegada da nossa confirma\u00e7\u00e3o de entrega. def time_delta ( t1 , t2 ): return int (( t2 - t1 )) ``` - Uma fun\u00e7\u00e3o responsavel por capturar o tempo em um determinado parte no c\u00f3digo . ``` py def get_time (): time_info = time . time () * 1000 return time_info ``` - Uma fun\u00e7\u00e3o respons\u00e1vel por formatal o tamanho do nosso payload . ``` py def formatpayload ( SIZE_PAYLOAD ): payload = \"0\" * SIZE_PAYLOAD return payload Por \u00faltimos irei definir algumas variav\u00e9is que iremos utilizar em nosso c\u00f3digo. broker_address : str = \"192.168.15.3\" COUNTClient : int = 0 REQUEST_TYPE : str = \"MQTT\" PUBLISH_TIMEOUT : int = 10000 SIZE_PAYLOAD : int = 6 PORT_HOST : int = 1883 WAIT_TIME : int = 1 Segue abaixo o c\u00f3digo completo. locustfile.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import time from locust import User , TaskSet , events , task , constant import paho.mqtt.client as mqtt from utils import get_time , formatpayload , time_delta from message import Message broker_address : str = \"192.168.15.3\" COUNTClient : int = 0 REQUEST_TYPE : str = \"MQTT\" PUBLISH_TIMEOUT : int = 10000 SIZE_PAYLOAD : int = 6 PORT_HOST : int = 1883 WAIT_TIME : int = 1 def increment (): global COUNTClient COUNTClient = COUNTClient + 1 class PublishTask ( TaskSet ): def on_start ( self ): self . client . connect ( host = broker_address , port = PORT_HOST , keepalive = 60 ) @task ( 1 ) def task_pub ( self ): self . client . loop_start () self . start_time = get_time () topic = str ( self . client . _client_id ) payload = formatpayload ( SIZE_PAYLOAD ) MQTTMessageInfo = self . client . publish ( topic , payload , qos = 1 , retain = False ) pub_mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) MQTTMessageInfo . mid = \" {} - {} \" . format ( MQTTMessageInfo . mid , self . client . _client_id . decode ()) self . client . user_data_set ( pub_mid ) self . client . pubmessage [ pub_mid ] = Message ( REQUEST_TYPE , 1 , topic , payload , self . start_time , PUBLISH_TIMEOUT , str ( self . client . _client_id ), ) MQTTMessageInfo . wait_for_publish () self . client . loop_stop () def on_stop ( self ): global COUNTClient COUNTClient = 0 return super () . on_stop () class MQTTLocust ( User ): tasks = { PublishTask } _locust_environment = None wait_time = constant ( WAIT_TIME ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) increment () self . client_name = \"Device - \" + str ( COUNTClient ) self . client = mqtt . Client ( self . client_name ) self . client . on_connect = self . on_connect self . client . on_publish = self . on_publish self . client . pubmessage = {} def on_connect ( client , userdata , flags , rc , props = None ): print ( \"Connect\" ) def on_publish ( self , client , userdata , mid ): self . end_time = get_time () mid = \" {} - {} \" . format ( mid , self . client_name ) message = client . pubmessage . pop ( mid , None ) total_time = time_delta ( message . start_time , self . end_time ) events . request . fire ( request_type = REQUEST_TYPE , name = \" {} \" . format ( str ( self . client_name )), response_time = total_time , response_length = len ( message . payload ), response = None , context = {}, exception = None , start_time = message . start_time , url = None , ) utils.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time def time_delta ( t1 , t2 ): return int (( t2 - t1 )) def get_time (): time_info = time . time () * 1000 return time_info def formatpayload ( SIZE_PAYLOAD ): payload = \"0\" * SIZE_PAYLOAD return payload message.py 1 2 3 4 5 6 7 8 9 class Message ( object ): def __init__ ( self , type , qos , topic , payload , start_time , timeout , name ): self . type = ( type ,) self . qos = ( qos ,) self . topic = topic self . payload = payload self . start_time = start_time self . timeout = timeout self . name = name Agora que j\u00e1 foi explicado as partes mais importantes do c\u00f3digo iremos rodar esse comando no terminal. Shell locust -f locustfile.py","title":"Utils"},{"location":"path/","text":"O projeto est\u00e1 disponibilizado no github e qualquer atualiza\u00e7\u00e3o ser\u00e1 disponibiliza. Aqui iremos dar uma breve explica\u00e7\u00e3o como est\u00e1 a organiza\u00e7\u00e3o dos diret\u00f3rios. Segue abaixo os diret\u00f3rios disponiv\u00e9is no projeto: . |-- Data_analytics |-- Documentation |-- Locust |-- README.md |-- certificadoSSL |-- mosquitto `-- mosquittotls 6 directories, 1 file Data_analytics Esse Diret\u00f3rio ser\u00e1 responsavel por armazenar os resultados das simula\u00e7\u00f5es e os scripts para tratamento desses dados. Aqui irei utilizar um padr\u00e3o de nomenclatura para as pastas, tentando sempre manter a maior organiza\u00e7\u00e3o e uma maior agilizade ao analisarmos os dados. Segue padr\u00e3o abaixo. device-[x]-sizepayload-[y]-lines-[z] x = Ser\u00e1 substituido pela quantidade de dispositivos que foram testados. y = Ser\u00e1 substituido pelo tamanho do nosso payload. z = Ser\u00e1 substituido pela quantidade de mensagens que foram trocadas POR usuario. exemplo: device-5-sizepayload-6-msg-100 Nesse exemplo dado acima iremos encontrar os resultados de um teste realizado com 5 devices, um payload de tamanho 6 bytes, e cada um desses usuarios realizou 100 publica\u00e7\u00f5es. Exemplo de arquivos encontrados dentro do diret\u00f3rio Data_analytics/device-5-sizepayload-6-msg-100 . Explica\u00e7\u00e3o de cada um est\u00e1 ao lado dos nomes. device-5-sizepayload-6-msg-100 |-- Test\\ Report\\ for\\ locustfile.py.html # Um relat\u00f3rio disponibilizado pelo pr\u00f3prio locust ap\u00f3s a simula\u00e7\u00e3o. |-- data.csv # Dados capturados pelo Wireshark em formato csv para analise de dados. |-- data_wireshark.pcapng # Dados capturados pelo Wireshark em formato pcapng. |-- exceptions_1668211736.780954.csv # Um relat\u00f3rio de possiveis exce\u00e7\u00f5es na simula\u00e7\u00e3o |-- failures_1668211735.9747043.csv # Um relat\u00f3rio de possiveis falhas na simula\u00e7\u00e3o |-- relatorio.ipynb # Um jupyterNotebook contendo os scripts utilizados para tratamento de dados da simula\u00e7\u00e3o `-- requests_1668211735.3653195.csv # Um relat\u00f3rio das requisi\u00e7\u00f5es Documentation Esse diret\u00f3rio foi utilizado para criar a documenta\u00e7\u00e3o. Documentation . |-- README.txt |-- docs | |-- code.md | |-- image | |-- index.md | |-- path.md | `-- tamanho_da_amos.md |-- mkdocs.yml `-- requirements.txt Se necess\u00e1rio rodar a documenta\u00e7\u00e3o seguir o README.txt com todos os passos necess\u00e1rios para a utiliza\u00e7\u00e3o. Locust Esse diret\u00f3rio iremos encontrar os scripts que foram utilizados para as simula\u00e7\u00f5es. Locust . |-- README.txt |-- requirements.txt `-- src |-- locustfile.py #Simula\u00e7\u00e3o sem tls |-- locustfileTLS.py #Simula\u00e7\u00e3o com tls |-- message.py #classe que iremos utilizar dentro dos dois arquivos acima `-- utils.py #fun\u00e7\u00f5es que iremos utilizar nos dois primeiros arquivos Dentro desse diret\u00f3rio tamb\u00e9m foi inserido um README.txt com algumas instru\u00e7\u00f5es de como rodar as simula\u00e7\u00f5es. mosquitto e mosquittotls Dentro desses diret\u00f3rios iremos encontrar os arquivos necess\u00e1rios para configurarmos o broker mqtt, o diret\u00f3rio denominado mosquitto n\u00e3o possui a pasta config/certs, pois n\u00e3o apresenta necessidade, j\u00e1 no mosquittotls iremos necessitar dos certificados. mosquittotls |-- config | |-- certs | | |-- ca.crt | | |-- ca.key | | |-- ca.srl | | |-- server.crt | | |-- server.csr | | `-- server.key | `-- mosquitto.conf |-- data |-- docker-compose.yml `-- log `-- mosquitto.log","title":"Estrutura de Pastas"},{"location":"path/#data_analytics","text":"Esse Diret\u00f3rio ser\u00e1 responsavel por armazenar os resultados das simula\u00e7\u00f5es e os scripts para tratamento desses dados. Aqui irei utilizar um padr\u00e3o de nomenclatura para as pastas, tentando sempre manter a maior organiza\u00e7\u00e3o e uma maior agilizade ao analisarmos os dados. Segue padr\u00e3o abaixo. device-[x]-sizepayload-[y]-lines-[z] x = Ser\u00e1 substituido pela quantidade de dispositivos que foram testados. y = Ser\u00e1 substituido pelo tamanho do nosso payload. z = Ser\u00e1 substituido pela quantidade de mensagens que foram trocadas POR usuario. exemplo: device-5-sizepayload-6-msg-100 Nesse exemplo dado acima iremos encontrar os resultados de um teste realizado com 5 devices, um payload de tamanho 6 bytes, e cada um desses usuarios realizou 100 publica\u00e7\u00f5es. Exemplo de arquivos encontrados dentro do diret\u00f3rio Data_analytics/device-5-sizepayload-6-msg-100 . Explica\u00e7\u00e3o de cada um est\u00e1 ao lado dos nomes. device-5-sizepayload-6-msg-100 |-- Test\\ Report\\ for\\ locustfile.py.html # Um relat\u00f3rio disponibilizado pelo pr\u00f3prio locust ap\u00f3s a simula\u00e7\u00e3o. |-- data.csv # Dados capturados pelo Wireshark em formato csv para analise de dados. |-- data_wireshark.pcapng # Dados capturados pelo Wireshark em formato pcapng. |-- exceptions_1668211736.780954.csv # Um relat\u00f3rio de possiveis exce\u00e7\u00f5es na simula\u00e7\u00e3o |-- failures_1668211735.9747043.csv # Um relat\u00f3rio de possiveis falhas na simula\u00e7\u00e3o |-- relatorio.ipynb # Um jupyterNotebook contendo os scripts utilizados para tratamento de dados da simula\u00e7\u00e3o `-- requests_1668211735.3653195.csv # Um relat\u00f3rio das requisi\u00e7\u00f5es","title":"Data_analytics"},{"location":"path/#documentation","text":"Esse diret\u00f3rio foi utilizado para criar a documenta\u00e7\u00e3o. Documentation . |-- README.txt |-- docs | |-- code.md | |-- image | |-- index.md | |-- path.md | `-- tamanho_da_amos.md |-- mkdocs.yml `-- requirements.txt Se necess\u00e1rio rodar a documenta\u00e7\u00e3o seguir o README.txt com todos os passos necess\u00e1rios para a utiliza\u00e7\u00e3o.","title":"Documentation"},{"location":"path/#locust","text":"Esse diret\u00f3rio iremos encontrar os scripts que foram utilizados para as simula\u00e7\u00f5es. Locust . |-- README.txt |-- requirements.txt `-- src |-- locustfile.py #Simula\u00e7\u00e3o sem tls |-- locustfileTLS.py #Simula\u00e7\u00e3o com tls |-- message.py #classe que iremos utilizar dentro dos dois arquivos acima `-- utils.py #fun\u00e7\u00f5es que iremos utilizar nos dois primeiros arquivos Dentro desse diret\u00f3rio tamb\u00e9m foi inserido um README.txt com algumas instru\u00e7\u00f5es de como rodar as simula\u00e7\u00f5es.","title":"Locust"},{"location":"path/#mosquitto-e-mosquittotls","text":"Dentro desses diret\u00f3rios iremos encontrar os arquivos necess\u00e1rios para configurarmos o broker mqtt, o diret\u00f3rio denominado mosquitto n\u00e3o possui a pasta config/certs, pois n\u00e3o apresenta necessidade, j\u00e1 no mosquittotls iremos necessitar dos certificados. mosquittotls |-- config | |-- certs | | |-- ca.crt | | |-- ca.key | | |-- ca.srl | | |-- server.crt | | |-- server.csr | | `-- server.key | `-- mosquitto.conf |-- data |-- docker-compose.yml `-- log `-- mosquitto.log","title":"mosquitto e mosquittotls"},{"location":"tamanho_da_amos/","text":"DETERMINA\u00c7\u00c3O DO TAMANHO AMOSTRAL Introdu\u00e7\u00e3o Atrav\u00e9s de uma pr\u00e9-amostragem, denominada de amostragem piloto, calcula-se o n\u00famero de unidades amostrais necess\u00e1rias para compor a amostra representativa da popula\u00e7\u00e3o dentro do limite de erro estipulado ou estabelecido. Agora que j\u00e1 sabemos rodar o projeto, ser\u00e1 realizada uma simula\u00e7\u00e3o e ser\u00e3o capituradas as trocas de mensagens entre o broker e um cliente simulado por nosso projeto. Lembrando que nossas informa\u00e7\u00f5es ser\u00e3o capturadas de 2 modos, um que ser\u00e1 pelo pr\u00f3prio Locust e um segundo modo ser\u00e1 pelo Wireshark para que seja possivel realizar estudos em cima dos nossos dados. Ap\u00f3s a obten\u00e7\u00e3o dos dados pelo Wireshark iremos salva-los em formato csv e iremos tratar esses dados em um script em python que tamb\u00e9m ser\u00e1 disponibilizado e explicado mais a frente. Logo abaixo deixamos uma pequena parte do nosso arquivo da simula\u00e7\u00e3o da amostra piloto. amostra_piloto.csv \"No.\",\"Time\",\"Source\",\"Destination\",\"Protocol\",\"Length\",\"Topic\",\"Message Identifier\",\"Source Port\",\"Destination Port\",\"Info\" \"185\",\"26.021096759\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"90\",\"\",\"\",\"37953\",\"1883\",\"Connect Command\" \"187\",\"26.023436459\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"1\",\"37953\",\"1883\",\"Publish Message (id=1) [Deviceb'Device - 1']\" \"188\",\"26.023917838\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"\",\"1883\",\"37953\",\"Connect Ack\" \"191\",\"26.026219616\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"1\",\"1883\",\"37953\",\"Publish Ack (id=1)\" \"198\",\"27.028577195\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"2\",\"37953\",\"1883\",\"Publish Message (id=2) [Deviceb'Device - 1']\" \"200\",\"27.031371904\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"2\",\"1883\",\"37953\",\"Publish Ack (id=2)\" \"212\",\"28.033880087\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"3\",\"37953\",\"1883\",\"Publish Message (id=3) [Deviceb'Device - 1']\" \"214\",\"28.036671599\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"3\",\"1883\",\"37953\",\"Publish Ack (id=3)\" \"220\",\"29.038713357\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"4\",\"37953\",\"1883\",\"Publish Message (id=4) [Deviceb'Device - 1']\" \"221\",\"29.041346621\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"4\",\"1883\",\"37953\",\"Publish Ack (id=4)\" \"235\",\"30.042764932\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"5\",\"37953\",\"1883\",\"Publish Message (id=5) [Deviceb'Device - 1']\" Ap\u00f3s realizarmos a simula\u00e7\u00e3o vamos come\u00e7ar a analisar nosso script em python para tratarmos e estudarmos os dados. Nossa amostra piloto ficou salva no seguinte caminho Data_analytics/device-1-sizepayload-6-msg-600/data.csv Tratamento dos dados Primeiro iremos realizar as importa\u00e7\u00f5es necess\u00e1rias para que nosso script execute perfeitamente. relatorio.ipynb import pandas as pd import re import matplotlib.pyplot as plt import scipy import numpy as np Nesse trecho de c\u00f3digo iremos utilizar a biblioteca pandas para ler nossos dados no formato csv. relatorio.ipynb data = pd . read_csv ( \"./data.csv\" ) ports = data [ \"Source Port\" ] . unique () ports = ports [ ports != 1883 ] ports ports array([37953]) Logo acima capturamos as portas TCP de cada um dos dispositivos. O que nos possibilita separarmos as informa\u00e7\u00f5es por dispositivo. Cada um dos valores da lista ports representa um dispositivo testado na nossa simula\u00e7\u00e3o.Nesse caso em especifico estamos utilizando apenas um dispotivo na porta 37953. Para calcularmos o Round Trip Time precisamos capturar as linhas que possuem a informa\u00e7\u00e3o Publish Message e as linhas que apresent\u00e3o a confirma\u00e7\u00e3o de entrega que s\u00e3o as linhas que possuem a informa\u00e7\u00e3o Publish Ack . Logo abaixo iremos capturar as informa\u00e7\u00f5es necessarias e iremos separar por device e suas respctivas Publish Message e Publish Ack . relatorio.ipynb devices = {} # : devices ser\u00e1 um dicionario que ir\u00e1 ter uma chave referente ao device e o valor ser\u00e1 um dataframe referente aos respectivos devices for port in ports : array_publish = data . loc [ data [ \"Source Port\" ] == port ] . dropna ( subset = [ 'Message Identifier' ]) array_publish_ack = data . loc [ data [ \"Destination Port\" ] == port ] . dropna ( subset = [ 'Message Identifier' ]) device = { \"publish\" : array_publish , \"publish_ack\" : array_publish_ack } devices [ port ] = device Logo abaixo construi uma l\u00f3gica para utilizarmos as informa\u00e7\u00f5es dos dados extraidos acima e calculamos o round trip time de cada um dos dispositivos. relatorio.ipynb data = {} for port in ports : RTT = pd . DataFrame ( columns = [ \"Time_publish\" , \"Time_ack\" ]) for index , row in devices [ port ][ \"publish\" ] . iterrows (): id = int ( row [ \"Message Identifier\" ]) time_publish = row [ \"Time\" ] RTT . loc [ id , \"Time_publish\" ] = time_publish for index , row in devices [ port ][ \"publish_ack\" ] . iterrows (): id = int ( row [ \"Message Identifier\" ]) time_publish = row [ \"Time\" ] RTT . loc [ id , \"Time_ack\" ] = time_publish RTT . loc [ id , \"Time_ack\" ] = time_publish RTT [ \"RTT\" ] = ( RTT [ \"Time_ack\" ] - RTT [ \"Time_publish\" ] ) * 1000 data [ port ] = RTT Agora j\u00e1 temos calculado todas as linhas de cada um dos dispositivos. data[37953].head() Time_publish Time_ack RTT 1 26.023436 26.02622 2.783157 2 27.028577 27.031372 2.794709 3 28.03388 28.036672 2.791512 4 29.038713 29.041347 2.633264 5 30.042765 30.045957 3.19254 Agora que analisamos como est\u00e1 nossa tabela depois de todas as manipula\u00e7\u00f5es vamos calcular a m\u00e9dia, moda, desvio padr\u00e3o e mais algumas informa\u00e7\u00f5es. Lembrando que nesse caso estamos tratando os dados de um dispositivo mas o c\u00f3digo foi escrito para suportar um ou mais dispositivos. i = 1 data_mean = [] data_median = [] data_std = [] data_min = [] data_max = [] for port in ports : data_mean . append ( data [ port ][ \"RTT\" ] . mean ()) data_median . append ( data [ port ][ \"RTT\" ] . mean ()) data_std . append ( data [ port ][ \"RTT\" ] . mean ()) data_min . append ( data [ port ][ \"RTT\" ] . mean ()) data_max . append ( data [ port ][ \"RTT\" ] . mean ()) print ( \"(Device- {} )Mean Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . mean ())) print ( \"(Device- {} )Median Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . median ())) print ( \"(Device- {} )Standard deviation Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . std ())) print ( \"(Device- {} )Min Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . min ())) print ( \"(Device- {} )Max Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . max ())) print ( \"---------------------------------------------------------------\" ) i += 1 output (Device-1)Mean Round Trip Time = 2.794579920265673 (Device-1)Median Round Trip Time = 2.6867750000008073 (Device-1)Standard deviation Round Trip Time = 0.6409882996918244 (Device-1)Min Round Trip Time = 2.37513999991279 (Device-1)Max Round Trip Time = 12.155039000049328 --------------------------------------------------------------- Conceitos b\u00e1sicos de estat\u00edstica Para calcularmos o n\u00famero de amostras precisamos entender alguns conceitos b\u00e1sicos, irei abordar de forma breve para darmos andamento nos calculos. Intervalo de confian\u00e7a Um intervalo de confian\u00e7a \u00e9 uma amplitude de valores, que s\u00e3o derivadas de estat\u00edsticas de amostras, que tem a probabilidade de conter o valor de um par\u00e2metro populacional desconhecido. O n\u00edvel de confian\u00e7a ( \\(1 - \\alpha\\) ) representa a probabilidade de acerto da estimativa. De forma complementar o n\u00edvel de signific\u00e2ncia ( \\(\\alpha\\) ) expressa a probabilidade de erro da estimativa. O n\u00edvel de confian\u00e7a representa o grau de confiabilidade do resultado da estimativa estar dentro de determinado intervalo. Quando fixamos em uma pesquisa um n\u00edvel de confian\u00e7a de 95%, por exemplo, estamos assumindo que existe uma probabilidade de 95% dos resultados da pesquisa representarem bem a realidade, ou seja, estarem corretos. O n\u00edvel de confian\u00e7a de uma estimativa pode ser obtido a partir da \u00e1rea sob a curva normal como ilustrado na figura abaixo. Score Z \u00c9 o quanto uma medida se afasta da m\u00e9dia em termos de Desvios Padr\u00e3o. Quando o escore Z \u00e9 positivo isto indica que o dado est\u00e1 acima da m\u00e9dia e quando o mesmo \u00e9 negativo significa que o dado est\u00e1 abaixo da m\u00e9dia. Seus valores oscilam entre -3 < Z < +3 e isto corresponde a 99,72% da \u00e1rea sob a curva da Distribui\u00e7\u00e3o Normal. Em nosso estudo iremos utilizar um nivel de confian\u00e7a igual a 95% e se consultarmos a tabela de Distribui\u00e7\u00e3o normal iremos encontrar um z \u00e9 aproximadamente 1,96. Z = 1,96 (tabela da Distribui\u00e7\u00e3o Normal) Calculando o n\u00famero de amostra Para o calculo do n\u00famero de amostra iremos utilizar a seguinte formula: \\[n = \\left(z\\frac{s}{e}\\right)^2\\] onde: \\(z\\) = vari\u00e1vel normal padronizada \\(s\\) = desvio padr\u00e3o amostral \\(e\\) = erro inferencial Calculando o desvio padr\u00e3o \\(s\\) relatorio.ipynb desvio_padrao_amostral = data [ 37953 ][ \"RTT\" ] . std () desvio_padrao_amostral \\[ desvioPadraoAmostral = 9.329458861571394 \\] Calculando o Erro Voltando ao nosso script teremos que adicionar as seguintes linhas de c\u00f3digo para calcularmos o tamanho amostral relatorio.ipynb media = data [ 37953 ][ \"RTT\" ] . mean () e = 0.05 * media e \\[ e = 0.2284361217568699 \\] Calculando o tamanho da nossa amostra relatorio.ipynb n = ( z * ( s / e )) ** 2 n \\[ n = 80.83944240619886 \\] O c\u00f3digo que foi explicado acima se localiza no diret\u00f3rio Data_analytics/device-1-sizepayload-6-msg-600/relatorio.ipynb Com isso finalizamos o calculo do n\u00famero de amostra que iremos utilizar para nosso estudo. Lembrando que todos os c\u00f3digos estaram disponiveis no github.","title":"Definindo tamanho de amostra"},{"location":"tamanho_da_amos/#determinacao-do-tamanho-amostral","text":"","title":"DETERMINA\u00c7\u00c3O DO TAMANHO AMOSTRAL"},{"location":"tamanho_da_amos/#introducao","text":"Atrav\u00e9s de uma pr\u00e9-amostragem, denominada de amostragem piloto, calcula-se o n\u00famero de unidades amostrais necess\u00e1rias para compor a amostra representativa da popula\u00e7\u00e3o dentro do limite de erro estipulado ou estabelecido. Agora que j\u00e1 sabemos rodar o projeto, ser\u00e1 realizada uma simula\u00e7\u00e3o e ser\u00e3o capituradas as trocas de mensagens entre o broker e um cliente simulado por nosso projeto. Lembrando que nossas informa\u00e7\u00f5es ser\u00e3o capturadas de 2 modos, um que ser\u00e1 pelo pr\u00f3prio Locust e um segundo modo ser\u00e1 pelo Wireshark para que seja possivel realizar estudos em cima dos nossos dados. Ap\u00f3s a obten\u00e7\u00e3o dos dados pelo Wireshark iremos salva-los em formato csv e iremos tratar esses dados em um script em python que tamb\u00e9m ser\u00e1 disponibilizado e explicado mais a frente. Logo abaixo deixamos uma pequena parte do nosso arquivo da simula\u00e7\u00e3o da amostra piloto. amostra_piloto.csv \"No.\",\"Time\",\"Source\",\"Destination\",\"Protocol\",\"Length\",\"Topic\",\"Message Identifier\",\"Source Port\",\"Destination Port\",\"Info\" \"185\",\"26.021096759\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"90\",\"\",\"\",\"37953\",\"1883\",\"Connect Command\" \"187\",\"26.023436459\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"1\",\"37953\",\"1883\",\"Publish Message (id=1) [Deviceb'Device - 1']\" \"188\",\"26.023917838\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"\",\"1883\",\"37953\",\"Connect Ack\" \"191\",\"26.026219616\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"1\",\"1883\",\"37953\",\"Publish Ack (id=1)\" \"198\",\"27.028577195\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"2\",\"37953\",\"1883\",\"Publish Message (id=2) [Deviceb'Device - 1']\" \"200\",\"27.031371904\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"2\",\"1883\",\"37953\",\"Publish Ack (id=2)\" \"212\",\"28.033880087\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"3\",\"37953\",\"1883\",\"Publish Message (id=3) [Deviceb'Device - 1']\" \"214\",\"28.036671599\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"3\",\"1883\",\"37953\",\"Publish Ack (id=3)\" \"220\",\"29.038713357\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"4\",\"37953\",\"1883\",\"Publish Message (id=4) [Deviceb'Device - 1']\" \"221\",\"29.041346621\",\"192.168.15.3\",\"192.168.15.4\",\"MQTT\",\"70\",\"\",\"4\",\"1883\",\"37953\",\"Publish Ack (id=4)\" \"235\",\"30.042764932\",\"192.168.15.4\",\"192.168.15.3\",\"MQTT\",\"97\",\"Deviceb'Device - 1'\",\"5\",\"37953\",\"1883\",\"Publish Message (id=5) [Deviceb'Device - 1']\" Ap\u00f3s realizarmos a simula\u00e7\u00e3o vamos come\u00e7ar a analisar nosso script em python para tratarmos e estudarmos os dados. Nossa amostra piloto ficou salva no seguinte caminho Data_analytics/device-1-sizepayload-6-msg-600/data.csv","title":"Introdu\u00e7\u00e3o"},{"location":"tamanho_da_amos/#tratamento-dos-dados","text":"Primeiro iremos realizar as importa\u00e7\u00f5es necess\u00e1rias para que nosso script execute perfeitamente. relatorio.ipynb import pandas as pd import re import matplotlib.pyplot as plt import scipy import numpy as np Nesse trecho de c\u00f3digo iremos utilizar a biblioteca pandas para ler nossos dados no formato csv. relatorio.ipynb data = pd . read_csv ( \"./data.csv\" ) ports = data [ \"Source Port\" ] . unique () ports = ports [ ports != 1883 ] ports ports array([37953]) Logo acima capturamos as portas TCP de cada um dos dispositivos. O que nos possibilita separarmos as informa\u00e7\u00f5es por dispositivo. Cada um dos valores da lista ports representa um dispositivo testado na nossa simula\u00e7\u00e3o.Nesse caso em especifico estamos utilizando apenas um dispotivo na porta 37953. Para calcularmos o Round Trip Time precisamos capturar as linhas que possuem a informa\u00e7\u00e3o Publish Message e as linhas que apresent\u00e3o a confirma\u00e7\u00e3o de entrega que s\u00e3o as linhas que possuem a informa\u00e7\u00e3o Publish Ack . Logo abaixo iremos capturar as informa\u00e7\u00f5es necessarias e iremos separar por device e suas respctivas Publish Message e Publish Ack . relatorio.ipynb devices = {} # : devices ser\u00e1 um dicionario que ir\u00e1 ter uma chave referente ao device e o valor ser\u00e1 um dataframe referente aos respectivos devices for port in ports : array_publish = data . loc [ data [ \"Source Port\" ] == port ] . dropna ( subset = [ 'Message Identifier' ]) array_publish_ack = data . loc [ data [ \"Destination Port\" ] == port ] . dropna ( subset = [ 'Message Identifier' ]) device = { \"publish\" : array_publish , \"publish_ack\" : array_publish_ack } devices [ port ] = device Logo abaixo construi uma l\u00f3gica para utilizarmos as informa\u00e7\u00f5es dos dados extraidos acima e calculamos o round trip time de cada um dos dispositivos. relatorio.ipynb data = {} for port in ports : RTT = pd . DataFrame ( columns = [ \"Time_publish\" , \"Time_ack\" ]) for index , row in devices [ port ][ \"publish\" ] . iterrows (): id = int ( row [ \"Message Identifier\" ]) time_publish = row [ \"Time\" ] RTT . loc [ id , \"Time_publish\" ] = time_publish for index , row in devices [ port ][ \"publish_ack\" ] . iterrows (): id = int ( row [ \"Message Identifier\" ]) time_publish = row [ \"Time\" ] RTT . loc [ id , \"Time_ack\" ] = time_publish RTT . loc [ id , \"Time_ack\" ] = time_publish RTT [ \"RTT\" ] = ( RTT [ \"Time_ack\" ] - RTT [ \"Time_publish\" ] ) * 1000 data [ port ] = RTT Agora j\u00e1 temos calculado todas as linhas de cada um dos dispositivos. data[37953].head() Time_publish Time_ack RTT 1 26.023436 26.02622 2.783157 2 27.028577 27.031372 2.794709 3 28.03388 28.036672 2.791512 4 29.038713 29.041347 2.633264 5 30.042765 30.045957 3.19254 Agora que analisamos como est\u00e1 nossa tabela depois de todas as manipula\u00e7\u00f5es vamos calcular a m\u00e9dia, moda, desvio padr\u00e3o e mais algumas informa\u00e7\u00f5es. Lembrando que nesse caso estamos tratando os dados de um dispositivo mas o c\u00f3digo foi escrito para suportar um ou mais dispositivos. i = 1 data_mean = [] data_median = [] data_std = [] data_min = [] data_max = [] for port in ports : data_mean . append ( data [ port ][ \"RTT\" ] . mean ()) data_median . append ( data [ port ][ \"RTT\" ] . mean ()) data_std . append ( data [ port ][ \"RTT\" ] . mean ()) data_min . append ( data [ port ][ \"RTT\" ] . mean ()) data_max . append ( data [ port ][ \"RTT\" ] . mean ()) print ( \"(Device- {} )Mean Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . mean ())) print ( \"(Device- {} )Median Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . median ())) print ( \"(Device- {} )Standard deviation Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . std ())) print ( \"(Device- {} )Min Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . min ())) print ( \"(Device- {} )Max Round Trip Time = {} \" . format ( i , data [ port ][ \"RTT\" ] . max ())) print ( \"---------------------------------------------------------------\" ) i += 1 output (Device-1)Mean Round Trip Time = 2.794579920265673 (Device-1)Median Round Trip Time = 2.6867750000008073 (Device-1)Standard deviation Round Trip Time = 0.6409882996918244 (Device-1)Min Round Trip Time = 2.37513999991279 (Device-1)Max Round Trip Time = 12.155039000049328 ---------------------------------------------------------------","title":"Tratamento dos dados"},{"location":"tamanho_da_amos/#conceitos-basicos-de-estatistica","text":"Para calcularmos o n\u00famero de amostras precisamos entender alguns conceitos b\u00e1sicos, irei abordar de forma breve para darmos andamento nos calculos.","title":"Conceitos b\u00e1sicos de estat\u00edstica"},{"location":"tamanho_da_amos/#intervalo-de-confianca","text":"Um intervalo de confian\u00e7a \u00e9 uma amplitude de valores, que s\u00e3o derivadas de estat\u00edsticas de amostras, que tem a probabilidade de conter o valor de um par\u00e2metro populacional desconhecido. O n\u00edvel de confian\u00e7a ( \\(1 - \\alpha\\) ) representa a probabilidade de acerto da estimativa. De forma complementar o n\u00edvel de signific\u00e2ncia ( \\(\\alpha\\) ) expressa a probabilidade de erro da estimativa. O n\u00edvel de confian\u00e7a representa o grau de confiabilidade do resultado da estimativa estar dentro de determinado intervalo. Quando fixamos em uma pesquisa um n\u00edvel de confian\u00e7a de 95%, por exemplo, estamos assumindo que existe uma probabilidade de 95% dos resultados da pesquisa representarem bem a realidade, ou seja, estarem corretos. O n\u00edvel de confian\u00e7a de uma estimativa pode ser obtido a partir da \u00e1rea sob a curva normal como ilustrado na figura abaixo.","title":"Intervalo de confian\u00e7a"},{"location":"tamanho_da_amos/#score-z","text":"\u00c9 o quanto uma medida se afasta da m\u00e9dia em termos de Desvios Padr\u00e3o. Quando o escore Z \u00e9 positivo isto indica que o dado est\u00e1 acima da m\u00e9dia e quando o mesmo \u00e9 negativo significa que o dado est\u00e1 abaixo da m\u00e9dia. Seus valores oscilam entre -3 < Z < +3 e isto corresponde a 99,72% da \u00e1rea sob a curva da Distribui\u00e7\u00e3o Normal. Em nosso estudo iremos utilizar um nivel de confian\u00e7a igual a 95% e se consultarmos a tabela de Distribui\u00e7\u00e3o normal iremos encontrar um z \u00e9 aproximadamente 1,96. Z = 1,96 (tabela da Distribui\u00e7\u00e3o Normal)","title":"Score Z"},{"location":"tamanho_da_amos/#calculando-o-numero-de-amostra","text":"Para o calculo do n\u00famero de amostra iremos utilizar a seguinte formula: \\[n = \\left(z\\frac{s}{e}\\right)^2\\] onde: \\(z\\) = vari\u00e1vel normal padronizada \\(s\\) = desvio padr\u00e3o amostral \\(e\\) = erro inferencial","title":"Calculando o n\u00famero de amostra"},{"location":"tamanho_da_amos/#calculando-o-desvio-padrao-s","text":"relatorio.ipynb desvio_padrao_amostral = data [ 37953 ][ \"RTT\" ] . std () desvio_padrao_amostral \\[ desvioPadraoAmostral = 9.329458861571394 \\]","title":"Calculando o desvio padr\u00e3o \\(s\\)"},{"location":"tamanho_da_amos/#calculando-o-erro","text":"Voltando ao nosso script teremos que adicionar as seguintes linhas de c\u00f3digo para calcularmos o tamanho amostral relatorio.ipynb media = data [ 37953 ][ \"RTT\" ] . mean () e = 0.05 * media e \\[ e = 0.2284361217568699 \\]","title":"Calculando o Erro"},{"location":"tamanho_da_amos/#calculando-o-tamanho-da-nossa-amostra","text":"relatorio.ipynb n = ( z * ( s / e )) ** 2 n \\[ n = 80.83944240619886 \\] O c\u00f3digo que foi explicado acima se localiza no diret\u00f3rio Data_analytics/device-1-sizepayload-6-msg-600/relatorio.ipynb Com isso finalizamos o calculo do n\u00famero de amostra que iremos utilizar para nosso estudo. Lembrando que todos os c\u00f3digos estaram disponiveis no github.","title":"Calculando o tamanho da nossa amostra"}]}